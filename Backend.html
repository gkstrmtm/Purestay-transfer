<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>PureStay • Backend</title>
  <meta name="robots" content="noindex,nofollow" />
  <link rel="icon" href="brand/purestay_exact_SVG.svg" type="image/svg+xml">
  <style>
    :root{ --ink:#101010; --muted:#5a5854; --card:#fff; --line:#ece6dc; --gold:#CEA43C; --bg:#f7f5f2; }
    *{ box-sizing:border-box; }
    html, body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Helvetica, Arial;
      color:var(--ink);
      background: var(--bg);
    }
    a{ color:inherit; text-decoration:none; }

    .app{ min-height:100vh; display:grid; grid-template-columns: 260px 1fr; }
    @media (max-width: 980px){ .app{ grid-template-columns: 1fr; } }

    .side{
      position:sticky; top:0; align-self:start;
      height:100vh;
      padding:18px;
      border-right:1px solid var(--line);
      background:#fff;
    }
    @media (max-width: 980px){
      .side{ position:relative; height:auto; border-right:none; border-bottom:1px solid var(--line); }
    }

    .side__brand{ display:flex; gap:12px; align-items:center; padding:10px; border-radius:14px; }
    .side__brand:hover{ background:#faf8f5; }
    .side__brand img{ width:36px; height:36px; }
    .side__title{ font-weight:1000; letter-spacing:-0.01em; }
    .side__sub{ font-size:12px; color:var(--muted); font-weight:800; margin-top:2px; }

    .side__nav{ margin-top:12px; display:grid; gap:6px; }
    .side__hr{ height:1px; background:var(--line); margin:10px 6px; }
    .side__link{ padding:10px 12px; border-radius:12px; font-weight:900; color:#1b1b1b; }
    .side__link:hover{ background:#faf8f5; }
    .side__link.small{ font-weight:900; color:#363636; }

    .main{ padding:26px; }
    @media (max-width: 980px){ .main{ padding:18px; } }

    .panel{
      max-width: 980px;
      margin:0 auto;
      background: var(--card);
      border:1px solid var(--line);
      border-radius:18px;
      overflow:hidden;
      box-shadow: 0 18px 50px rgba(0,0,0,.06);
    }

    .panel__head{
      padding:18px 18px 14px;
      border-bottom:1px solid var(--line);
      display:flex; align-items:flex-start; justify-content:space-between; gap:12px; flex-wrap:wrap;
    }
    .panel__head h1{ margin:0; font-size:22px; letter-spacing:-0.02em; }
    .panel__head p{ margin:6px 0 0; color:var(--muted); font-weight:700; }

    .actions{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

    .section{ padding:18px; border-top:1px solid var(--line); }
    .section:first-of-type{ border-top:none; }
    .section h2{ margin:0; font-size:16px; letter-spacing:-0.01em; }
    .muted{ margin:6px 0 0; color:var(--muted); font-weight:700; }

    .grid{ display:grid; grid-template-columns: 1fr 1fr; gap:12px; margin-top:12px; }
    @media (max-width: 900px){ .grid{ grid-template-columns:1fr; } }

    label{ display:block; font-weight:1000; font-size:13px; margin-bottom:6px; }
    input, textarea{
      width:100%;
      border:1px solid #e6e0d6;
      border-radius:12px;
      padding:12px 12px;
      font-size:15px;
      outline:none;
      background:#fff;
    }
    textarea{ min-height:110px; resize:vertical; }
    input:focus, textarea:focus{ border-color: var(--gold); box-shadow:0 0 0 3px rgba(206,164,60,.22); }

    .btn{
      appearance:none;
      border:1px solid transparent;
      background:linear-gradient(180deg, var(--gold), #ffd98c);
      color:#1b1208;
      padding:12px 14px;
      border-radius:12px;
      font-weight:1000;
      cursor:pointer;
    }
    .btn.secondary{
      background:#fff;
      border-color:#e6e0d6;
      color:#111;
    }

    .btn.danger{
      background:#fff;
      border-color:#f0c9c9;
      color:#7a1f1f;
    }

    .status{ font-weight:900; font-size:14px; }
    .ok{ color:#0b6b2b; }
    .bad{ color:#7a1f1f; }
  </style>
</head>
<body>
  <div class="app">
    <aside class="side">
      <a class="side__brand" href="/" aria-label="PureStay Home">
        <img src="brand/purestay_exact_SVG.svg" alt="PureStay" />
        <div>
          <div class="side__title">Backend</div>
          <div class="side__sub">Settings</div>
        </div>
      </a>

      <nav class="side__nav" aria-label="Backend sections">
        <a class="side__link" href="#calendar">Booking link</a>
        <a class="side__link" href="#payments">Payments</a>
        <a class="side__link" href="#notes">Notes</a>
        <a class="side__link" href="#blogs">Blogs</a>
        <a class="side__link" href="#security">Save access</a>

        <div class="side__hr" role="presentation"></div>

        <a class="side__link small" href="/">Home</a>
        <a class="side__link small" href="/discovery">Discovery</a>
        <a class="side__link small" href="/dialer-training">Training</a>
        <a class="side__link small" href="/blogs">Blogs</a>
      </nav>
    </aside>

    <main class="main">
      <div class="panel">
        <header class="panel__head">
          <div>
            <h1>Settings</h1>
            <p>Update the links used across the site.</p>
          </div>
          <div class="actions">
            <button class="btn" id="btnSave" type="button">Save</button>
            <button class="btn secondary" id="btnReload" type="button">Reload</button>
            <span class="status" id="status"></span>
          </div>
        </header>

        <section class="section" id="calendar">
          <h2>Booking link</h2>
          <p class="muted">Where “Book a call” buttons should send people.</p>
          <div style="margin-top:12px;">
            <label for="bookingCalendarUrl">URL</label>
            <input id="bookingCalendarUrl" type="url" placeholder="https://..." />
          </div>
        </section>

        <section class="section" id="payments">
          <h2>Payments</h2>
          <p class="muted">Optional links for checkout and pricing.</p>
          <div class="grid">
            <div>
              <label for="stripeCheckoutUrl">Stripe checkout URL</label>
              <input id="stripeCheckoutUrl" type="url" placeholder="https://buy.stripe.com/..." />
            </div>
            <div>
              <label for="stripePricingUrl">Stripe pricing URL</label>
              <input id="stripePricingUrl" type="url" placeholder="https://..." />
            </div>
          </div>
        </section>

        <section class="section" id="notes">
          <h2>Notes</h2>
          <p class="muted">Paste anything you want to keep on hand.</p>
          <div style="margin-top:12px;">
            <label for="googleSheets">Notes</label>
            <textarea id="googleSheets" placeholder="Add links, notes, or reminders..."></textarea>
          </div>
        </section>

        <section class="section" id="blogs">
          <h2>Blogs</h2>
          <p class="muted">Generate and store real SEO blogs. Backfill creates posts one-by-one across a range (no placeholders).</p>

          <div class="grid">
            <div>
              <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:12px;">
                <button class="btn" id="btnBlogGenerate" type="button">Generate next blog</button>
                <button class="btn secondary" id="btnBlogBackfill" type="button">Generate next backfill</button>
                <button class="btn secondary" id="btnBlogBackfillAll" type="button">Generate backfill (all)</button>
                <button class="btn danger" id="btnBlogDeleteAll" type="button">Delete all blogs</button>
                <button class="btn secondary" id="btnBlogRefresh" type="button">Refresh</button>
              </div>

              <div class="grid" style="margin-top:12px; grid-template-columns: 1fr 1fr;">
                <div>
                  <label for="blogStartDate">Start date (YYYY-MM-DD)</label>
                  <input id="blogStartDate" type="text" placeholder="2024-01-01" />
                </div>
                <div>
                  <label for="blogEndDate">End date (YYYY-MM-DD)</label>
                  <input id="blogEndDate" type="text" placeholder="2026-02-23" />
                </div>
                <div>
                  <label for="blogStepDays">Spacing (days)</label>
                  <input id="blogStepDays" type="number" min="1" max="30" value="3" />
                </div>
                <div>
                  <label for="blogBatchSize">Batch per request</label>
                  <input id="blogBatchSize" type="number" min="1" max="5" value="1" />
                </div>
              </div>

              <div style="margin-top:12px;">
                <div class="status" id="blogStatus"></div>
                <div class="muted" id="blogMeta" style="margin-top:6px;"></div>
                <div class="muted" id="blogEstimate" style="margin-top:6px;"></div>
                <div class="muted" id="blogLast" style="margin-top:6px;"></div>
              </div>
            </div>

            <div>
              <label>Notes</label>
              <div class="status ok" style="margin-top:8px;">Backfill generates real posts into storage</div>
              <p class="muted" style="margin-top:10px;">If KV isn’t configured on Vercel, generation will fail. “Generate backfill (all)” loops until the API returns done.</p>
            </div>
          </div>
        </section>

        <section class="section" id="security">
          <h2>Save access</h2>
          <p class="muted">Only needed if saving is locked. If Save works without it, you can ignore this.</p>
          <div style="margin-top:12px; max-width:520px;">
            <label for="adminToken">Save key (optional)</label>
            <input id="adminToken" type="password" placeholder="(optional)" />
          </div>
        </section>
      </div>
    </main>
  </div>

  <script>
    (function(){
      const $ = (id)=>document.getElementById(id);
      const fields = {
        bookingCalendarUrl: $('bookingCalendarUrl'),
        stripeCheckoutUrl: $('stripeCheckoutUrl'),
        stripePricingUrl: $('stripePricingUrl'),
        googleSheets: $('googleSheets'),
        adminToken: $('adminToken'),
        status: $('status'),
        btnSave: $('btnSave'),
        btnReload: $('btnReload'),

        btnBlogGenerate: $('btnBlogGenerate'),
        btnBlogBackfill: $('btnBlogBackfill'),
        btnBlogBackfillAll: $('btnBlogBackfillAll'),
        btnBlogDeleteAll: $('btnBlogDeleteAll'),
        btnBlogRefresh: $('btnBlogRefresh'),
        blogStartDate: $('blogStartDate'),
        blogEndDate: $('blogEndDate'),
        blogStepDays: $('blogStepDays'),
        blogBatchSize: $('blogBatchSize'),
        blogStatus: $('blogStatus'),
        blogMeta: $('blogMeta'),
        blogEstimate: $('blogEstimate'),
        blogLast: $('blogLast'),
      };

      // Prefill from localStorage to reduce retyping
      try{
        const t = localStorage.getItem('ps_admin_token');
        if(t) fields.adminToken.value = t;
      }catch{}

      const BLOG_CURSOR_KEY = 'ps_blog_backfill_cursor';
      const BLOG_CFG_KEY = 'ps_blog_backfill_cfg_v2';

      function readBlogCursor(){
        try{ return (localStorage.getItem(BLOG_CURSOR_KEY) || '').trim(); }catch{ return ''; }
      }

      function writeBlogCursor(v){
        try{
          const s = (v || '').trim();
          if(!s) localStorage.removeItem(BLOG_CURSOR_KEY);
          else localStorage.setItem(BLOG_CURSOR_KEY, s);
        }catch{}
      }

      function readBlogCfg(){
        try{
          const raw = localStorage.getItem(BLOG_CFG_KEY) || '';
          const j = raw ? JSON.parse(raw) : null;
          return j && typeof j === 'object' ? j : {};
        }catch{ return {}; }
      }

      function writeBlogCfg(cfg){
        try{ localStorage.setItem(BLOG_CFG_KEY, JSON.stringify(cfg || {})); }catch{}
      }

      function yyyyMmDd(d){
        const pad = (n)=>String(n).padStart(2,'0');
        return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}`;
      }

      function defaultRange(){
        const end = new Date();
        const start = new Date(end);
        start.setFullYear(start.getFullYear() - 2);
        return { startDate: yyyyMmDd(start), endDate: yyyyMmDd(end) };
      }

      function getBackfillInputs(){
        const startDate = (fields.blogStartDate.value || '').trim();
        const endDate = (fields.blogEndDate.value || '').trim();
        const stepDays = Number(fields.blogStepDays.value || 3);
        const batchSize = Number(fields.blogBatchSize.value || 1);
        return { startDate, endDate, stepDays, batchSize };
      }

      function persistBackfillInputs(){
        writeBlogCfg(getBackfillInputs());
      }

      function loadBackfillInputs(){
        const d = defaultRange();
        const cfg = readBlogCfg();

        fields.blogStartDate.value = (cfg.startDate || fields.blogStartDate.value || d.startDate);
        fields.blogEndDate.value = (cfg.endDate || fields.blogEndDate.value || d.endDate);
        fields.blogStepDays.value = String(cfg.stepDays || fields.blogStepDays.value || 3);
        fields.blogBatchSize.value = String(cfg.batchSize || fields.blogBatchSize.value || 1);

        updateBackfillEstimate();
      }

      function parseDateOnly(s){
        const raw = String(s || '').trim();
        const m = raw.match(/^(\d{4})-(\d{2})-(\d{2})$/);
        if(!m) return null;
        const d = new Date(`${m[1]}-${m[2]}-${m[3]}T12:00:00.000Z`);
        return Number.isNaN(d.getTime()) ? null : d;
      }

      function updateBackfillEstimate(){
        const v = getBackfillInputs();
        const start = parseDateOnly(v.startDate);
        const end = parseDateOnly(v.endDate);
        const step = Number(v.stepDays || 0);
        if(!start || !end || !Number.isFinite(step) || step <= 0) {
          fields.blogEstimate.textContent = '';
          return;
        }
        const ms = end.getTime() - start.getTime();
        if(ms < 0) {
          fields.blogEstimate.textContent = 'Range looks reversed (start is after end).';
          return;
        }
        const days = Math.floor(ms / (24*60*60*1000));
        const count = Math.floor(days / step) + 1;
        fields.blogEstimate.textContent = `Estimate: ~${count} posts (every ${step} days).`;
      }

      ['input','change'].forEach((evt)=>{
        fields.blogStartDate.addEventListener(evt, updateBackfillEstimate);
        fields.blogEndDate.addEventListener(evt, updateBackfillEstimate);
        fields.blogStepDays.addEventListener(evt, updateBackfillEstimate);
      });


      function setStatus(msg, ok=true){
        fields.status.textContent = msg;
        fields.status.className = 'status ' + (ok ? 'ok' : 'bad');
      }

      async function load(){
        setStatus('Loading…');
        try{
          const r = await fetch('/api/settings', { method:'GET' });
          const j = await r.json().catch(()=>null);
          if(!j || !j.ok) throw new Error('load_failed');
          const s = j.settings || {};
          fields.bookingCalendarUrl.value = s.bookingCalendarUrl || '';
          fields.stripeCheckoutUrl.value = s.stripeCheckoutUrl || '';
          fields.stripePricingUrl.value = s.stripePricingUrl || '';
          fields.googleSheets.value = s.googleSheets || '';
          setStatus('Loaded.', true);
        }catch{
          setStatus('Could not load settings.', false);
        }
      }

      async function save(){
        const token = (fields.adminToken.value || '').trim();
        // remember token locally (if provided)
        if(token){
          try{ localStorage.setItem('ps_admin_token', token); }catch{}
        }

        setStatus('Saving…');
        const body = {
          bookingCalendarUrl: fields.bookingCalendarUrl.value.trim(),
          stripeCheckoutUrl: fields.stripeCheckoutUrl.value.trim(),
          stripePricingUrl: fields.stripePricingUrl.value.trim(),
          googleSheets: fields.googleSheets.value.trim(),
        };

        try{
          const r = await fetch('/api/settings', {
            method:'POST',
            headers:{
              'Content-Type':'application/json',
              ...(token ? { 'Authorization': 'Bearer ' + token } : {}),
            },
            body: JSON.stringify(body)
          });
          const j = await r.json().catch(()=>null);
          if(!r.ok || !j || !j.ok){
            const err = (j && j.error) ? String(j.error) : 'save_failed';
            if(err === 'unauthorized') setStatus('Save locked. Enter the save key, then try again.', false);
            else setStatus('Save failed.', false);
            return;
          }
          setStatus('Saved.', true);
        }catch{
          setStatus('Save failed.', false);
        }
      }

      fields.btnSave.addEventListener('click', save);
      fields.btnReload.addEventListener('click', load);

      function blogSetStatus(msg, ok=true){
        fields.blogStatus.textContent = msg;
        fields.blogStatus.className = 'status ' + (ok ? 'ok' : 'bad');
      }

      function blogSetBusy(isBusy){
        fields.btnBlogGenerate.disabled = isBusy;
        fields.btnBlogBackfill.disabled = isBusy;
        fields.btnBlogBackfillAll.disabled = isBusy;
        fields.btnBlogDeleteAll.disabled = isBusy;
        fields.btnBlogRefresh.disabled = isBusy;
      }

      async function blogLoadStatus(){
        const token = (fields.adminToken.value || '').trim();
        blogSetStatus('Loading blogs…', true);
        fields.blogMeta.textContent = '';
        fields.blogEstimate.textContent = '';
        fields.blogLast.textContent = '';
        try{
          const r = await fetch('/api/blogs/status', {
            method:'GET',
            headers: {
              ...(token ? { 'Authorization': 'Bearer ' + token } : {}),
            }
          });
          const j = await r.json().catch(()=>null);
          if(!r.ok || !j || !j.ok) throw new Error('status_failed');

          const total = Number(j.total || 0);
          const mode = String(j.mode || 'disabled');

          blogSetStatus('Ready.', true);
          if(mode !== 'kv'){
            fields.blogMeta.textContent = 'Mode: Not configured (KV missing on Vercel).';
          } else {
            fields.blogMeta.textContent = `Mode: Stored (KV) • Total posts: ${total}`;
          }

          const latest = j.latest;
          if(latest && latest.slug){
            fields.blogLast.innerHTML = `Latest: <a href="/blogs/${latest.slug}" style="text-decoration:underline;">${latest.title || latest.slug}</a>`;
          } else {
            if(mode === 'kv') fields.blogLast.textContent = 'No posts yet.';
          }

        }catch{
          blogSetStatus('Could not load blog status.', false);
        }
      }

      async function blogGenerateNext(){
        const token = (fields.adminToken.value || '').trim();
        blogSetStatus('Generating blog…', true);
        try{
          const r = await fetch('/api/blogs/generate', {
            method:'POST',
            headers:{
              'Content-Type':'application/json',
              ...(token ? { 'Authorization': 'Bearer ' + token } : {}),
            },
            body: JSON.stringify({ publishedAt: new Date().toISOString() }),
          });
          const j = await r.json().catch(()=>null);
          if(!r.ok || !j || !j.ok) throw new Error((j && j.error) ? String(j.error) : 'generate_failed');
          blogSetStatus('Generated.', true);
          if(j.slug){
            fields.blogLast.innerHTML = `Latest: <a href="/blogs/${j.slug}" style="text-decoration:underline;">Open generated post</a>`;
          }
          await blogLoadStatus();
        }catch(e){
          blogSetStatus(`Generation failed: ${e && e.message ? e.message : 'unknown'}`, false);
        }
      }

      async function blogBackfillNext(){
        const token = (fields.adminToken.value || '').trim();
        blogSetStatus('Generating backfill…', true);
        try{
          const cursor = readBlogCursor();
          persistBackfillInputs();
          const cfg = getBackfillInputs();
          const r = await fetch('/api/blogs/backfill-next', {
            method:'POST',
            headers:{
              'Content-Type':'application/json',
              ...(token ? { 'Authorization': 'Bearer ' + token } : {}),
            },
            body: JSON.stringify({ ...cfg, ...(cursor ? { cursor } : {}) }),
          });
          const j = await r.json().catch(()=>null);
          if(!r.ok || !j || !j.ok) throw new Error((j && j.error) ? String(j.error) : 'backfill_failed');

          if(j.nextCursor) writeBlogCursor(String(j.nextCursor));
          if(j.done){
            blogSetStatus('Backfill complete.', true);
            writeBlogCursor('');
          } else {
            const n = Array.isArray(j.generated) ? j.generated.length : 1;
            blogSetStatus(`Backfill generated (${n}).`, true);
          }

          const last = Array.isArray(j.generated) && j.generated.length ? j.generated[j.generated.length - 1] : null;
          if(last && last.slug){
            fields.blogLast.innerHTML = `Latest: <a href="/blogs/${last.slug}" style="text-decoration:underline;">Open generated post</a>`;
          } else if(j.slug){
            fields.blogLast.innerHTML = `Latest: <a href="/blogs/${j.slug}" style="text-decoration:underline;">Open generated post</a>`;
          }
          await blogLoadStatus();
        }catch(e){
          blogSetStatus(`Backfill failed: ${e && e.message ? e.message : 'unknown'}`, false);
        }
      }

      async function blogBackfillAll(){
        const token = (fields.adminToken.value || '').trim();
        blogSetBusy(true);
        blogSetStatus('Backfilling (loop)…', true);

        try{
          persistBackfillInputs();
          const cfg = getBackfillInputs();
          let cursor = readBlogCursor();
          let total = 0;

          for(let i = 0; i < 20000; i++){
            const r = await fetch('/api/blogs/backfill-next', {
              method:'POST',
              headers:{
                'Content-Type':'application/json',
                ...(token ? { 'Authorization': 'Bearer ' + token } : {}),
              },
              body: JSON.stringify({ ...cfg, ...(cursor ? { cursor } : {}) }),
            });
            const j = await r.json().catch(()=>null);
            if(!r.ok || !j || !j.ok) throw new Error((j && j.error) ? String(j.error) : 'backfill_failed');

            const n = Array.isArray(j.generated) ? j.generated.length : 0;
            total += n;

            if(j.nextCursor) {
              cursor = String(j.nextCursor);
              writeBlogCursor(cursor);
            }

            const last = Array.isArray(j.generated) && j.generated.length ? j.generated[j.generated.length - 1] : null;
            if(last && last.slug){
              fields.blogLast.innerHTML = `Latest: <a href="/blogs/${last.slug}" style="text-decoration:underline;">Open generated post</a>`;
            }

            if(j.done){
              blogSetStatus(`Backfill complete (${total} posts).`, true);
              writeBlogCursor('');
              break;
            }
            blogSetStatus(`Generated ${total}…`, true);
          }

          await blogLoadStatus();
        }catch(e){
          blogSetStatus(`Backfill failed: ${e && e.message ? e.message : 'unknown'}`, false);
        }finally{
          blogSetBusy(false);
        }
      }

      async function blogDeleteAll(){
        const token = (fields.adminToken.value || '').trim();
        if(!confirm('Delete ALL blog posts? This cannot be undone.')) return;
        blogSetBusy(true);
        blogSetStatus('Deleting…', true);
        try{
          const r = await fetch('/api/blogs/delete-all', {
            method:'POST',
            headers:{
              'Content-Type':'application/json',
              ...(token ? { 'Authorization': 'Bearer ' + token } : {}),
            },
            body: JSON.stringify({}),
          });
          const j = await r.json().catch(()=>null);
          if(!r.ok || !j || !j.ok) throw new Error((j && j.error) ? String(j.error) : 'delete_failed');
          writeBlogCursor('');
          blogSetStatus(`Deleted ${Number(j.deleted || 0)} posts.`, true);
          await blogLoadStatus();
        }catch(e){
          blogSetStatus(`Delete failed: ${e && e.message ? e.message : 'unknown'}`, false);
        }finally{
          blogSetBusy(false);
        }
      }

      fields.btnBlogGenerate.addEventListener('click', blogGenerateNext);
      fields.btnBlogBackfill.addEventListener('click', blogBackfillNext);
      fields.btnBlogBackfillAll.addEventListener('click', blogBackfillAll);
      fields.btnBlogDeleteAll.addEventListener('click', blogDeleteAll);
      fields.btnBlogRefresh.addEventListener('click', blogLoadStatus);

      load();
      loadBackfillInputs();
      blogLoadStatus();
    })();
  </script>
</body>
</html>
